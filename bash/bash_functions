# vim: ft=sh

# Quickly display / switch kubenernetes contexts
function kcsc
{
  local context=${1}
  if [[ -z "$context" ]]; then
    kubectl config get-contexts
  else
    kubectl config use-context ${context}
  fi
}

# Quickly display / switch kubenernetes namespaces
function kcns
{
  local namespace=${1}
  if [[ -z "$namespace" ]]; then
    kubectl get ns
  else
    local context=$(kubectl config current-context)
    echo "Setting context ${context} to namespace ${namespace}..."
    kubectl config set-context ${context} --namespace ${namespace}
  fi
}

# Get the WAN IPs of all nodes in a kubernetes cluster
# TODO: This is dirty, and not portable, clean it up.
function kube-nodes
{
  local nodes=$(kubectl get nodes | grep -E 'Ready[^,]' \
    | cut -d ' ' -f 1)

  for node in $nodes; do
    local node_wan=$(kubectl describe node/${node} \
      | awk -F, '/Addresses:/ {print $NF}')

    echo "$node - $node_wan"
  done
}

# Grab a shell / execute a comand on a running pod
function kube-shell
{
  local pod=${1:?}
  shift

  local cols=$(tput cols)
  local lines=$(tput lines)
  local term='xterm'
  local cmd=$@
  cmd=${cmd:-bash}

  kubectl exec -it $pod -- env COLUMNS=$cols LINES=$lines TERM=$term "$cmd"
}

# Use all resources in given file as Terraform resource targets
function terraform-target-file
{
  if [[ "$#" -ne 2 ]]; then
    echo "Requires two arguments: action target-file"
    return 1
  fi

  local action=${1:?}
  local target=${2:?}

  local resources=$(awk '/^resource/ { gsub(/"/, ""); printf "--target=%s.%s ", $2, $3 }' <"${target}")
  terraform $action $resources
}

#TODO: This is sloppy and not super portable. It works for now,
# but should definitely be cleaned up. At least add linux compat.
function clc
{
  tail -n1 "$HISTFILE" \
    | tee >(pbcopy)
}

function aws-keypair-fingerprint
{
  openssl pkcs8 -in "${1:?}" -nocrypt -topk8 -outform DER \
    | openssl sha1 -c
}

function div-line
{
  printf "%${2:-$(tput cols)}s\n" | tr " " "${1:--}"
}

function dick-line
{
  printf "8%${1:-80}sD\n" | tr " " "="
}

function mkbak
{
  local file=${1:?}
  cp "$file" "${file}.bak"
}

function cdl
{
  cd $1 \
    && ls -l
}

function ansistrip
{
  if [[ -z "$OSX" ]]; then
    sed -E "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" -i $1
  else
    gsed -E "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" -i $1
  fi
}

function mkcd
{
  local dir=${1:?}
  mkdir -p "$dir" && cd "$dir"
}

function scratch
{
  local file="$(date +%s).scratch"
  touch "$file"
  vim "$file"
}

function command_exists
{
  command -v "${1:?}" >/dev/null 2>&1
}

function psdt
{
    if [ -z "$1" ]; then
        echo "Missing parameter. Usage: psdt {pid | name}"
        return 0
    fi

    x=$1
    ps aux | awk -v search="$x" 'NR == 1; $0 ~ search' | grep -v awk

}

# Display all the colors / ANSI codes available to the term
function showcolors
{
    for x in 0 1 4 5 7 8; do 
        for i in `seq 30 37`; do 
            for a in `seq 40 47`; do 
                echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "
            done
            echo
        done
    done
    echo ""
}

# Show days passed since given date
# Borrowed from kjsharke
function ageDay
{ 
    echo $(( (`date +%s` - `date -d "$1" +%s`)/(3600*24) ));
}

# This function defines a 'cd' replacement function capable of keeping, 
# displaying and accessing history of visited directories, up to 10 entries.
# To use it, uncomment it, source this file and try 'cd --'.
# acd_func 1.0.5, 10-nov-2004
# Petar Marinov, http:/geocities.com/h2428, this is public domain
function cd_func
{
    local x2 the_new_dir adir index
    local -i cnt

    if [[ $1 ==  "--" ]]; then
        dirs -v
        return 0
    fi

    the_new_dir=$1
    [[ -z $1 ]] && the_new_dir=$HOME

    if [[ ${the_new_dir:0:1} == '-' ]]; then
        # Extract dir N from dirs
        index=${the_new_dir:1}
        [[ -z $index ]] && index=1
        adir=$(dirs +$index)
        [[ -z $adir ]] && return 1
        the_new_dir=$adir
    fi

    # '~' has to be substituted by ${HOME}
    [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

    # Now change to the new dir and add to the top of the stack
    pushd "${the_new_dir}" > /dev/null
    [[ $? -ne 0 ]] && return 1
    the_new_dir=$(pwd)

    # Trim down everything beyond 11th entry
    popd -n +11 2>/dev/null 1>/dev/null

    # Remove any other occurence of this dir, skipping the top of the stack
    for ((cnt=1; cnt <= 10; cnt++)); do
        x2=$(dirs +${cnt} 2>/dev/null)
        [[ $? -ne 0 ]] && return 0
        [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
        if [[ "${x2}" == "${the_new_dir}" ]]; then
        popd -n +$cnt 2>/dev/null 1>/dev/null
        cnt=cnt-1
        fi
    done

    return 0
}
alias cd='cd_func'

# Function to traverse "up" filesystem from CWD
# Credit to reddit user /u/spdqbr
# http://www.reddit.com/r/commandline/comments/2o7rvh/linux_whats_a_good_alternative_to_stuff_like_cd/cmksmek
function cdup {
    newdir="${PWD/\/$1\/*/}/$1"
    if [[ -d "$newdir" ]]
    then
        cd "$newdir"
    else
        echo "\"$newdir\" does not exist"
    fi
}

function _cdup_complete {
    local word=${COMP_WORDS[COMP_CWORD]}
    local list=$(pwd | cut -c 2- | sed -e 's#/[^/]*$##g' -e 's/\([ ()]\)/\\\\\1/g')
    IFS=/
    list=$(compgen -W "$list" -- "$word")
    IFS=$'\n'
    COMPREPLY=($list)
    return 0
}

complete -F _cdup_complete cdup
