# vim: ft=sh

# Quickly display / switch kubernetes contexts
function kcsc
{
  local context=${1}
  if [[ -z "$context" ]]; then
    kubectl config get-contexts
  else
    kubectl config use-context ${context}
  fi
}

function _kcsc_complete {
    local word=${COMP_WORDS[COMP_CWORD]}
    local list=$(kubectl config get-contexts --no-headers | tr -d '\*' | awk '{print $1}')
    list=$(compgen -W "$list" -- "$word")
    COMPREPLY=($list)
    return 0
}
complete -F _kcsc_complete kcsc

# Quickly display / switch kubernetes namespaces
function kcns
{
  local namespace=${1}
  if [[ -z "$namespace" ]]; then
    kubectl get ns
  else
    local context=$(kubectl config current-context)
    echo "Setting context ${context} to namespace ${namespace}..."
    kubectl config set-context ${context} --namespace ${namespace}
  fi
}

function _kcns_complete {
    local word=${COMP_WORDS[COMP_CWORD]}
    local list=$(kubectl get ns --no-headers | awk '{print $1}')
    list=$(compgen -W "$list" -- "$word")
    COMPREPLY=($list)
    return 0
}
complete -F _kcns_complete kcns

# Get the WAN IPs of all nodes in a kubernetes cluster
# TODO: This is dirty, and not portable, clean it up.
function kube-nodes
{
  local nodes=$(kubectl get nodes | grep -E 'Ready[^,]' \
    | cut -d ' ' -f 1)

  for node in $nodes; do
    local node_wan=$(kubectl describe node/${node} \
      | awk -F, '/Addresses:/ {print $NF}')

    echo "$node - $node_wan"
  done
}

# Get WAN IP of node for given pod
function kube-pod-wan
{
  local pod=${1:?}
  local node=$(kubectl describe po ${pod} \
    |awk '/^Node:/ { split($NF, node, "/"); print node[1] }')
  kubectl describe node ${node} \
  | awk -F',' '/^Addresses:/ {print $NF}'
}

# Grab a shell / execute a comand on a running pod
function kube-shell
{
  local pod=${1:?}
  shift

  # Some lazy argument parsing to see if a container is specified
  if  [[ "$1" == "-c" ]]; then
    shift
    local container=" -c ${1:?}"
    shift
  fi

  local cols=$(tput cols)
  local lines=$(tput lines)
  local term='xterm'
  local cmd=$@
  cmd=${cmd:-bash}

  kubectl exec -it $pod $container -- env COLUMNS=$cols LINES=$lines TERM=$term "$cmd"
}

# Use all resources in given file as Terraform resource targets
function terraform-target-file
{
  if [[ "$#" -ne 2 ]]; then
    echo "Requires two arguments: action target-file"
    return 1
  fi

  local action=${1:?}
  local target=${2:?}

  local resources=$(awk '/^resource/ { gsub(/"/, ""); printf "--target=%s.%s ", $2, $3 }' <"${target}")
  echo -e "Running:\nterraform $action --refresh=true ${resources}\n\n"
  terraform $action --refresh=true $resources
}

#### AWS related functions ####
# Get private IP owner
function aws-private-ip-search
{
  if [[ "$#" -lt 1 ]]; then
    echo "Usage: ${FUNCNAME} elb-name [region]"
    echo 'aws --region=${region} ec2 describe-network-interfaces --filters "Name=addresses.private-ip-address,Values=${ip}"'
    return 1
  fi

  local ip=${1:?}
  local region=${2:-us-west-2}

  aws --region=${region} ec2 describe-network-interfaces --filters "Name=addresses.private-ip-address,Values=${ip}" \
    | grep 'Description'
}

# Get the private IP addresses for internet facing ELB
function aws-elb-private-ip
{
  if [[ "$#" -lt 1 ]]; then
    echo "Usage: ${FUNCNAME} elb-name [region]"
    echo 'aws --region=\${region} ec2 describe-network-interfaces --filters "Name=description,Values=ELB ${elb}"'
    return 1
  fi

  local elb=${1:?}
  local region=${2:-us-west-2}

  # Some laziness to use jq if it's available, else use grep
  command -v "jq" >/dev/null 2>&1 \
    && (aws --region=${region} ec2 describe-network-interfaces --filters "Name=description,Values=ELB ${elb}" \
      | jq ".NetworkInterfaces[].PrivateIpAddresses[].PrivateIpAddress") \
    || (aws --region=${region} ec2 describe-network-interfaces --filters "Name=description,Values=ELB ${elb}" \
      | grep '\"PrivateIpAddress\":')
}

# Get the fingerprint of an AWS private key
function aws-keypair-fingerprint
{
  openssl pkcs8 -in "${1:?}" -nocrypt -topk8 -outform DER \
    | openssl sha1 -c
}

#TODO: This is sloppy and not super portable. It works for now,
# but should definitely be cleaned up. At least add linux compat.
function clc
{
  tail -n1 "$HISTFILE" \
    | tee >(pbcopy)
}

function div-line
{
  printf "%${2:-$(tput cols)}s\n" | tr " " "${1:--}"
}

function dick-line
{
  printf "8%${1:-80}sD\n" | tr " " "="
}

function mkbak
{
  local file=${1:?}
  cp "$file" "${file}.bak"
}

function cdl
{
  cd $1 \
    && ls -l
}

function ansistrip
{
  if [[ -z "$OSX" ]]; then
    sed -E "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" -i $1
  else
    gsed -E "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" -i $1
  fi
}

function mkcd
{
  local dir=${1:?}
  mkdir -p "$dir" && cd "$dir"
}

function scratch
{
  local file="$(date +%s).scratch"
  touch "$file"
  vim "$file"
}

function command_exists
{
  command -v "${1:?}" >/dev/null 2>&1
}

function psdt
{
    if [ -z "$1" ]; then
        echo "Missing parameter. Usage: psdt {pid | name}"
        return 0
    fi

    x=$1
    ps aux | awk -v search="$x" 'NR == 1; $0 ~ search' | grep -v awk

}

# Display all the colors / ANSI codes available to the term
function showcolors
{
    for x in 0 1 4 5 7 8; do 
        for i in `seq 30 37`; do 
            for a in `seq 40 47`; do 
                echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "
            done
            echo
        done
    done
    echo ""
}

function tv-static
{
  P=(' ' █ ░ ▒ ▓)
  while :
    do printf "\e[$[RANDOM%LINES+1];$[RANDOM%COLUMNS+1]f${P[$RANDOM%5]}"
  done
}

# Show days passed since given date
# Borrowed from kjsharke
function ageDay
{ 
    echo $(( (`date +%s` - `date -d "$1" +%s`)/(3600*24) ));
}

# This function defines a 'cd' replacement function capable of keeping, 
# displaying and accessing history of visited directories, up to 10 entries.
# To use it, uncomment it, source this file and try 'cd --'.
# acd_func 1.0.5, 10-nov-2004
# Petar Marinov, http:/geocities.com/h2428, this is public domain
function cd_func
{
    local x2 the_new_dir adir index
    local -i cnt

    if [[ $1 ==  "--" ]]; then
        dirs -v
        return 0
    fi

    the_new_dir=$1
    [[ -z $1 ]] && the_new_dir=$HOME

    if [[ ${the_new_dir:0:1} == '-' ]]; then
        # Extract dir N from dirs
        index=${the_new_dir:1}
        [[ -z $index ]] && index=1
        adir=$(dirs +$index)
        [[ -z $adir ]] && return 1
        the_new_dir=$adir
    fi

    # '~' has to be substituted by ${HOME}
    [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

    # Now change to the new dir and add to the top of the stack
    pushd "${the_new_dir}" > /dev/null
    [[ $? -ne 0 ]] && return 1
    the_new_dir=$(pwd)

    # Trim down everything beyond 11th entry
    popd -n +11 2>/dev/null 1>/dev/null

    # Remove any other occurence of this dir, skipping the top of the stack
    for ((cnt=1; cnt <= 10; cnt++)); do
        x2=$(dirs +${cnt} 2>/dev/null)
        [[ $? -ne 0 ]] && return 0
        [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
        if [[ "${x2}" == "${the_new_dir}" ]]; then
        popd -n +$cnt 2>/dev/null 1>/dev/null
        cnt=cnt-1
        fi
    done

    return 0
}
alias cd='cd_func'

# Function to traverse "up" filesystem from CWD
# Credit to reddit user /u/spdqbr
# http://www.reddit.com/r/commandline/comments/2o7rvh/linux_whats_a_good_alternative_to_stuff_like_cd/cmksmek
function cdup {
    newdir="${PWD/\/$1\/*/}/$1"
    if [[ -d "$newdir" ]]
    then
        cd "$newdir"
    else
        echo "\"$newdir\" does not exist"
    fi
}

function _cdup_complete {
    local word=${COMP_WORDS[COMP_CWORD]}
    local list=$(pwd | cut -c 2- | sed -e 's#/[^/]*$##g' -e 's/\([ ()]\)/\\\\\1/g')
    _IFS="$IFS"
    IFS=/
    list=$(compgen -W "$list" -- "$word")
    IFS="$_IFS"
    COMPREPLY=($list)
    return 0
}

complete -F _cdup_complete cdup

# Function to extract common compressed file types
function extract {
 if [ -z "$1" ]; then
    # display usage if no parameters given
    echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
 else
    if [ -f "$1" ] ; then
        local nameInLowerCase=`echo "$1" | awk '{print tolower($0)}'`
        case "$nameInLowerCase" in
          *.tar.bz2)   tar xvjf ./"$1"    ;;
          *.tar.gz)    tar xvzf ./"$1"    ;;
          *.tar.xz)    tar xvJf ./"$1"    ;;
          *.lzma)      unlzma ./"$1"      ;;
          *.bz2)       bunzip2 ./"$1"     ;;
          *.rar)       unrar x -ad ./"$1" ;;
          *.gz)        gunzip ./"$1"      ;;
          *.tar)       tar xvf ./"$1"     ;;
          *.tbz2)      tar xvjf ./"$1"    ;;
          *.tgz)       tar xvzf ./"$1"    ;;
          *.zip)       unzip ./"$1"       ;;
          *.Z)         uncompress ./"$1"  ;;
          *.7z)        7z x ./"$1"        ;;
          *.xz)        unxz ./"$1"        ;;
          *.exe)       cabextract ./"$1"  ;;
          *)           echo "extract: '$1' - unknown archive method" ;;
        esac
      else
        echo "'$1' - file does not exist"
      fi
  fi
}
