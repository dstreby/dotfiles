# vim: ft=sh

function aws-keypair-fingerprint
{
  openssl pkcs8 -in "${1:?}" -nocrypt -topk8 -outform DER \
    | openssl sha1 -c
}

function div-line
{
  printf "%${2:-$(tput cols)}s\n" | tr " " "${1:--}"
}

function dick-line
{
  printf "8%${1:-80}sD\n" | tr " " "="
}

function mkbak
{
  local file=${1:?}
  cp "$file" "${file}.bak"
}

function cdl
{
  cd $1 \
    && ls -l
}

function ansistrip
{
  if [[ -z "$OSX" ]]; then
    sed -E "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" -i $1
  else
    gsed -E "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" -i $1
  fi
}

function mkcd
{
  local dir=${1:?}
  mkdir -p "$dir" && cd "$dir"
}

function scratch
{
  local file="$(date +%s).scratch"
  touch "$file"
  vim "$file"
}

function command_exists
{
  command -v "${1:?}" >/dev/null 2>&1
}

function psdt
{
    if [ -z "$1" ]; then
        echo "Missing parameter. Usage: psdt {pid | name}"
        return 0
    fi

    x=$1
    ps aux | awk -v search="$x" 'NR == 1; $0 ~ search' | grep -v awk

}

# Display all the colors / ANSI codes available to the term
function showcolors
{
    for x in 0 1 4 5 7 8; do 
        for i in `seq 30 37`; do 
            for a in `seq 40 47`; do 
                echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "
            done
            echo
        done
    done
    echo ""
}

# Show days passed since given date
# Borrowed from kjsharke
function ageDay
{ 
    echo $(( (`date +%s` - `date -d "$1" +%s`)/(3600*24) ));
}

# This function defines a 'cd' replacement function capable of keeping, 
# displaying and accessing history of visited directories, up to 10 entries.
# To use it, uncomment it, source this file and try 'cd --'.
# acd_func 1.0.5, 10-nov-2004
# Petar Marinov, http:/geocities.com/h2428, this is public domain
function cd_func
{
    local x2 the_new_dir adir index
    local -i cnt

    if [[ $1 ==  "--" ]]; then
        dirs -v
        return 0
    fi

    the_new_dir=$1
    [[ -z $1 ]] && the_new_dir=$HOME

    if [[ ${the_new_dir:0:1} == '-' ]]; then
        # Extract dir N from dirs
        index=${the_new_dir:1}
        [[ -z $index ]] && index=1
        adir=$(dirs +$index)
        [[ -z $adir ]] && return 1
        the_new_dir=$adir
    fi

    # '~' has to be substituted by ${HOME}
    [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

    # Now change to the new dir and add to the top of the stack
    pushd "${the_new_dir}" > /dev/null
    [[ $? -ne 0 ]] && return 1
    the_new_dir=$(pwd)

    # Trim down everything beyond 11th entry
    popd -n +11 2>/dev/null 1>/dev/null

    # Remove any other occurence of this dir, skipping the top of the stack
    for ((cnt=1; cnt <= 10; cnt++)); do
        x2=$(dirs +${cnt} 2>/dev/null)
        [[ $? -ne 0 ]] && return 0
        [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
        if [[ "${x2}" == "${the_new_dir}" ]]; then
        popd -n +$cnt 2>/dev/null 1>/dev/null
        cnt=cnt-1
        fi
    done

    return 0
}
alias cd='cd_func'

# Function to traverse "up" filesystem from CWD
# Credit to reddit user /u/spdqbr
# http://www.reddit.com/r/commandline/comments/2o7rvh/linux_whats_a_good_alternative_to_stuff_like_cd/cmksmek
function cdup {
    newdir="${PWD/\/$1\/*/}/$1"
    if [[ -d "$newdir" ]]
    then
        cd "$newdir"
    else
        echo "\"$newdir\" does not exist"
    fi
}

function _cdup_complete {
    local word=${COMP_WORDS[COMP_CWORD]}
    local list=$(pwd | cut -c 2- | sed -e 's#/[^/]*$##g' -e 's/\([ ()]\)/\\\\\1/g')
    IFS=/
    list=$(compgen -W "$list" -- "$word")
    IFS=$'\n'
    COMPREPLY=($list)
    return 0
}

complete -F _cdup_complete cdup
