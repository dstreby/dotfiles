# vim: ft=sh

#### Kubernetes functions ####
# Quickly display / switch kubernetes contexts
function kcsc
{
  local context=${1}
  if [[ -z "$context" ]]; then
    kubectl config get-contexts
  else
    kubectl config use-context ${context}
  fi
}

function _kcsc_complete {
    local word=${COMP_WORDS[COMP_CWORD]}
    local list=$(kubectl config get-contexts --no-headers | tr -d '\*' | awk '{print $1}')
    list=$(compgen -W "$list" -- "$word")
    COMPREPLY=($list)
    return 0
}
complete -F _kcsc_complete kcsc

# Quickly display / switch kubernetes namespaces
function kcns
{
  local namespace=${1}
  if [[ -z "$namespace" ]]; then
    kubectl get ns
  else
    local context=$(kubectl config current-context)
    echo "Setting context ${context} to namespace ${namespace}..."
    kubectl config set-context ${context} --namespace ${namespace}
  fi
}

function _kcns_complete {
    local word=${COMP_WORDS[COMP_CWORD]}
    local list=$(kubectl get ns --no-headers | awk '{print $1}')
    list=$(compgen -W "$list" -- "$word")
    COMPREPLY=($list)
    return 0
}
complete -F _kcns_complete kcns

# Finds the WAN IP of a given kubernetes node
function kube-node-wan
{
  local node=${1:?}
  kubectl describe node/${node} \
    | awk '/Addresses/ {
        split($2, ips, ",");
        for (i in ips) {
          if ( match(ips[i], /(192\.168|10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.)/) == 0 ) {
            print ips[i]
          }
        }
      }'
}

# Lists all kubernetes worker nodes and their WAN IP
function kube-nodes
{
  local nodes=$(kubectl get nodes --no-headers \
    | grep -v 'SchedulingDisabled' \
    | cut -d ' ' -f 1
  )

  for node in $nodes; do
    local node_wan=$(kube-node-wan ${node})

    echo "$node - $node_wan"
  done
}

# Returns the WAN IP for the node on which a given pod is running
function kube-pod-wan
{
  local pod=${1:?}
  local node=$(kubectl describe po ${pod} \
    |awk '/^Node:/ { split($NF, node, "/"); print node[1] }')

  kube-node-wan $node
}

# A quick and dirty way to show the resource availability in a kube cluster
#TODO: This should be re-written and expanded
function kube-capacity {
  local nodes=$(kubectl get no --no-headers | awk '$0 !~ /Disabled/ {print $1}')
  for node in $nodes; do
    echo -n "Node ${node} - "
    kubectl describe no $node \
      | grep -A4 'Allocated resources' \
      | tail -n1 \
      | awk '{print "CPU Requests " $1 " " $2 " Memory Requests: " $5 " " $6}'
  done
}

# Grab a shell / execute a comand on a running pod
function kube-shell
{
  local pod=${1:?}
  shift

  # Some lazy argument parsing to see if a container is specified
  if  [[ "$1" == "-c" ]]; then
    shift
    local container=" -c ${1:?}"
    shift
  fi

  local cols=$(tput cols)
  local lines=$(tput lines)
  local term='xterm'
  local cmd=$@
  cmd=${cmd:-bash}

  kubectl exec -it $pod $container -- env COLUMNS=$cols LINES=$lines TERM=$term "$cmd"
}

#### Terraform functions ####
# Use all resources in given file as Terraform resource targets
function terraform-target-file
{
  if [[ "$#" -ne 2 ]]; then
    echo "Requires two arguments: action target-file"
    return 1
  fi

  local action=${1:?}
  local target=${2:?}

  local resources=$(awk '/^resource/ { gsub(/"/, ""); printf "--target=%s.%s ", $2, $3 }' <"${target}")
  echo -e "Running:\nterraform $action --refresh=true ${resources}\n\n"
  terraform $action --refresh=true $resources
}

#### AWS related functions ####
# Get ACM Certificate ARN(s)
function aws-cert-arn
{
  local search_string=${1}
  if [[ -z "$search_string" ]]; then
    aws acm list-certificates \
      | jq '.CertificateSummaryList|sort_by(.DomainName)'
  else
    aws acm list-certificates \
      | jq --arg search_string "$search_string" '.CertificateSummaryList[]|select(.DomainName | contains($search_string))'
  fi
}

# Get private IP owner
function aws-private-ip-search
{
  if [[ "$#" -lt 1 ]]; then
    echo "Usage: ${FUNCNAME} elb-name [region]"
    echo 'aws --region=${region} ec2 describe-network-interfaces --filters "Name=addresses.private-ip-address,Values=${ip}"'
    return 1
  fi

  local ip=${1:?}
  local region=${2:-us-west-2}

  aws --region=${region} ec2 describe-network-interfaces --filters "Name=addresses.private-ip-address,Values=${ip}" \
    | grep 'Description'
}

# Get the private IP addresses for internet facing ELB
function aws-elb-private-ip
{
  if [[ "$#" -lt 1 ]]; then
    echo "Usage: ${FUNCNAME} elb-name [region]"
    echo 'aws --region=\${region} ec2 describe-network-interfaces --filters "Name=description,Values=ELB ${elb}"'
    return 1
  fi

  local elb=${1:?}
  local region=${2:-us-west-2}

  # Some laziness to use jq if it's available, else use grep
  command -v "jq" >/dev/null 2>&1 \
    && (aws --region=${region} ec2 describe-network-interfaces --filters "Name=description,Values=ELB ${elb}" \
      | jq ".NetworkInterfaces[].PrivateIpAddresses[].PrivateIpAddress") \
    || (aws --region=${region} ec2 describe-network-interfaces --filters "Name=description,Values=ELB ${elb}" \
      | grep '\"PrivateIpAddress\":')
}

# Get the fingerprint of an AWS private key
function aws-keypair-fingerprint
{
  openssl pkcs8 -in "${1:?}" -nocrypt -topk8 -outform DER \
    | openssl sha1 -c
}

#TODO: This is sloppy and not super portable. It works for now,
# but should definitely be cleaned up. At least add linux compat.
function clc
{
  tail -n1 "$HISTFILE" \
    | tee >(pbcopy)
}

function die
{
  local frame=0
  while caller $frame; do
    ((frame++));
  done

  local format="$1"
  shift
  tput setaf 1
  printf >&2 "$format\n" "$@"
  tput sgr0

  return 1
}

function div-line
{
  printf "%${2:-$(tput cols)}s\n" | tr " " "${1:--}"
}

function dick-line
{
  printf "8%${1:-80}sD\n" | tr " " "="
}

function mkbak
{
  local file=${1:?}
  cp "$file" "${file}.bak"
}

function cdl
{
  cd $1 \
    && ls -l
}

function ansistrip
{
  if [[ -z "$OSX" ]]; then
    sed -E "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" -i $1
  else
    gsed -E "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" -i $1
  fi
}

function mkcd
{
  local dir=${1:?}
  mkdir -p "$dir" && cd "$dir"
}

function scratch
{
  local file="$(date +%s).scratch"
  touch "$file"
  vim "$file"
}

function command_exists
{
  command -v "${1:?}" >/dev/null 2>&1
}

function psdt
{
    if [ -z "$1" ]; then
        echo "Missing parameter. Usage: psdt {pid | name}"
        return 0
    fi

    x=$1
    ps aux | awk -v search="$x" 'NR == 1; $0 ~ search' | grep -v awk

}

# Display all the colors / ANSI codes available to the term
function showcolors
{
    for x in 0 1 4 5 7 8; do 
        for i in `seq 30 37`; do 
            for a in `seq 40 47`; do 
                echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "
            done
            echo
        done
    done
    echo ""
}

function tv-static
{
  P=(' ' █ ░ ▒ ▓)
  while :
    do printf "\e[$[RANDOM%LINES+1];$[RANDOM%COLUMNS+1]f${P[$RANDOM%5]}"
  done
}

function weather
{
  # We require 'curl' so check for it
  if ! command -v curl &>/dev/null; then
    printf "%s\n" "[ERROR] weather: This command requires 'curl', please install it."
    return 1
  fi

  # If no arg is given, default to New York, NY
  (curl -sm 10 "http://wttr.in/${*:-NewYork}" 2>/dev/null \
    | grep -v 'New feature\|Follow') \
    || printf "%s\n" "[ERROR] weather: Could not connect to weather service."
}

# Simple stock price function
# takes one positional arg for stock symbol
function ticker
{
  stock=${1:-aapl}
  url="http://download.finance.yahoo.com/d/quotes.csv?s=${stock}&f=l1cl"

  # We require 'curl' so check for it
  if ! command -v curl &>/dev/null; then
    printf "%s\n" "[ERROR] weather: This command requires 'curl', please install it."
    return 1
  fi

  ## Because bash on OSX apparently doesn't support case substitutions
  ## we'll waste a variable and a few cycles to get the stock symbol in uppercase
  stock_up=$(echo "$stock" | tr '[:lower:]' '[:upper:]')

  quote=$(curl -s "$url")
  quote=$(echo "$quote" \
    | tr '\",' ' ' \
    | tr -s ' '
  )
  read -ra quote_arr <<< "$quote"

  ## Figure out if the change is positive or negative
  if [ "${quote_arr[1]:0:1}" == "+" ]; then
    change_color="\033[00;32m"
  elif [ "${quote_arr[1]:0:1}" == "-" ]; then
    change_color="\033[00;31m"
  else
    change_color="\033[00m"
  fi

  if command -v figlet &>/dev/null; then
    echo "${quote_arr[0]}" | figlet -k
  else
    echo "${quote_arr[0]}"
  fi
  echo -e "${stock_up} ${change_color}${quote_arr[1]} [ ${quote_arr[3]} ]\033[00m"
  echo "$(date "+%Y-%m-%d") ${quote_arr[4]}"
}
export -f ticker

# Show days passed since given date
# Borrowed from kjsharke
function ageDay
{ 
    echo $(( (`date +%s` - `date -d "$1" +%s`)/(3600*24) ));
}

# This function defines a 'cd' replacement function capable of keeping, 
# displaying and accessing history of visited directories, up to 10 entries.
# To use it, uncomment it, source this file and try 'cd --'.
# acd_func 1.0.5, 10-nov-2004
# Petar Marinov, http:/geocities.com/h2428, this is public domain
function cd_func
{
    local x2 the_new_dir adir index
    local -i cnt

    if [[ $1 ==  "--" ]]; then
        dirs -v
        return 0
    fi

    the_new_dir=$1
    [[ -z $1 ]] && the_new_dir=$HOME

    if [[ ${the_new_dir:0:1} == '-' ]]; then
        # Extract dir N from dirs
        index=${the_new_dir:1}
        [[ -z $index ]] && index=1
        adir=$(dirs +$index)
        [[ -z $adir ]] && return 1
        the_new_dir=$adir
    fi

    # '~' has to be substituted by ${HOME}
    [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

    # Now change to the new dir and add to the top of the stack
    pushd "${the_new_dir}" > /dev/null
    [[ $? -ne 0 ]] && return 1
    the_new_dir=$(pwd)

    # Trim down everything beyond 11th entry
    popd -n +11 2>/dev/null 1>/dev/null

    # Remove any other occurence of this dir, skipping the top of the stack
    for ((cnt=1; cnt <= 10; cnt++)); do
        x2=$(dirs +${cnt} 2>/dev/null)
        [[ $? -ne 0 ]] && return 0
        [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
        if [[ "${x2}" == "${the_new_dir}" ]]; then
        popd -n +$cnt 2>/dev/null 1>/dev/null
        cnt=cnt-1
        fi
    done

    return 0
}
alias cd='cd_func'

# Function to traverse "up" filesystem from CWD
# Credit to reddit user /u/spdqbr
# http://www.reddit.com/r/commandline/comments/2o7rvh/linux_whats_a_good_alternative_to_stuff_like_cd/cmksmek
function cdup {
    newdir="${PWD/\/$1\/*/}/$1"
    if [[ -d "$newdir" ]]
    then
        cd "$newdir"
    else
        echo "\"$newdir\" does not exist"
    fi
}

function _cdup_complete {
    local word=${COMP_WORDS[COMP_CWORD]}
    local list=$(pwd | cut -c 2- | sed -e 's#/[^/]*$##g' -e 's/\([ ()]\)/\\\\\1/g')
    _IFS="$IFS"
    IFS=/
    list=$(compgen -W "$list" -- "$word")
    IFS="$_IFS"
    COMPREPLY=($list)
    return 0
}

complete -F _cdup_complete cdup

# Function to extract common compressed file types
function extract {
 if [ -z "$1" ]; then
    # display usage if no parameters given
    echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
 else
    if [ -f "$1" ] ; then
        local nameInLowerCase=`echo "$1" | awk '{print tolower($0)}'`
        case "$nameInLowerCase" in
          *.tar.bz2)   tar xvjf ./"$1"    ;;
          *.tar.gz)    tar xvzf ./"$1"    ;;
          *.tar.xz)    tar xvJf ./"$1"    ;;
          *.lzma)      unlzma ./"$1"      ;;
          *.bz2)       bunzip2 ./"$1"     ;;
          *.rar)       unrar x -ad ./"$1" ;;
          *.gz)        gunzip ./"$1"      ;;
          *.tar)       tar xvf ./"$1"     ;;
          *.tbz2)      tar xvjf ./"$1"    ;;
          *.tgz)       tar xvzf ./"$1"    ;;
          *.zip)       unzip ./"$1"       ;;
          *.Z)         uncompress ./"$1"  ;;
          *.7z)        7z x ./"$1"        ;;
          *.xz)        unxz ./"$1"        ;;
          *.exe)       cabextract ./"$1"  ;;
          *)           echo "extract: '$1' - unknown archive method" ;;
        esac
      else
        echo "'$1' - file does not exist"
      fi
  fi
}
