# Functions

bak()
{
    cp $1 "$1.bak"
}

mkcd()
{
    mkdir $1 && cd $1
}

psdt()
{
    if [ -z "$1" ]; then
        echo "Missing parameter. Usage: psdt {pid | name}"
        return 0
    fi
    
    x=$1
    ps aux | awk -v search="$x" 'NR == 1; $0 ~ search' | grep -v awk

}

soap()
{
    if [ $# -lt 2 ]; then
        echo "Missing parameter. Usage: soap {soap.xml} {url}"
        return 0
    fi
    
    curl -s -d @$1 $2 | \
        sed -e 's/\s\{2,\}/ /g' | \
        xmllint --format - | \
        pygmentize -f terminal256 -l xml -O style=monokai

}

allgit()
{
	if [ -z "$1" ]
	then
		echo Checking all git repositories in Home Directory...
		DIR=$HOME
	elif [ "$1" == "." ]
	then
		echo Checking all git repositories in $PWD...
		DIR=$1
	else
		echo Checking all git repositories in $1...
		DIR=$1
	fi

	for REPO in `find $DIR -name ".git" -type d`; do
	   WD=$(echo $REPO | awk -F/.git '{print $1}')
	   echo "-------------------------------------------------------------"
	   echo $WD | awk -v home="$HOME" '{ sub(home, "~"); print "Repository at: ", $0;}'
	   git --git-dir=$REPO --work-tree=$WD status 2>/dev/null | \
		 awk 'NR==1 {
				branch = $4
			}
			NR==2 {
				if($6=="clean)")printf("\t\033[0;32mBranch: \"%s\" is clean :)\033[0m\n",branch); 
				else printf("\t\033[0;31mBranch: \"%s\" is Dirty :(\033[0m\n",branch);
			}'
	done
}

gitstrip()
{
    if [ -z "$1" ]
    then
        echo Requires file-name to strip
        return 1
    fi

	BRANCH=$(git status 2>/dev/null | \
		 awk 'NR==1 { print $4 }')

    echo "Stripping file: $1" 
    echo "From repo branch $BRANCH"
    echo "Are you sure you'd like to continue? Y/N"
  
    read -s -n1 CONFIRM
    if [[ "$CONFIRM" != "y" && "$CONFIRM" != "Y" ]]; then
        echo "Exiting."
        return 0
    fi

    echo "*********************************************"
    
    git filter-branch --force --index-filter \
    "git rm --cached --ignore-unmatch $1" \
    --prune-empty --tag-name-filter cat -- --all

    echo "$1" >> .gitignore

    git add .gitignore    
    git commit -m "Added $1 to .gitignore"

    echo "*********************************************"
    echo "Push commit to remote using 'git push origin $BRANCH --force'"

}

passgen()
{
    if [ -z "$1" ]
    then
        echo Generating password with default length 16
		LEN=16
    else
        echo Generating password with length $1
		LEN=$1
	fi
    < /dev/urandom tr -dc [:graph:] | \
		head -c$LEN | \
		sed -e "s/.\(.\).\(.\).\(.*\)/$(< /dev/urandom tr -dc "0-9" | \
		head -c1)\1$(< /dev/urandom tr -dc "a-z" | \
		head -c1)\2$(< /dev/urandom tr -dc "A-Z" | \
		head -c1)\3/" | \
		tee /dev/clipboard
    echo 
}

parse_git_branch()
{
  git status 2>/dev/null | \
    awk 'NR==1 {
        branch = $4
    } 
    NR==2 {
        if( $2=="Untracked" )
            printf( "\033[00;37m(\033[00;31m %s \033[00;37m) \033[01;41;37m + \033[0m\n", branch );
        else if( $6=="clean)" )
            printf( "\033[00;37m(\033[00;32m %s \033[00;37m)\033[0m\n", branch );
        else
            printf( "\033[00;37m(\033[00;31m %s \033[00;37m) \033[01;41;37m * \033[0m\n", branch );
    }'
}

# This function defines a 'cd' replacement function capable of keeping, 
# displaying and accessing history of visited directories, up to 10 entries.
# To use it, uncomment it, source this file and try 'cd --'.
# acd_func 1.0.5, 10-nov-2004
# Petar Marinov, http:/geocities.com/h2428, this is public domain
cd_func ()
{
    local x2 the_new_dir adir index
    local -i cnt

    if [[ $1 ==  "--" ]]; then
        dirs -v
        return 0
    fi

    the_new_dir=$1
    [[ -z $1 ]] && the_new_dir=$HOME

    if [[ ${the_new_dir:0:1} == '-' ]]; then
        # Extract dir N from dirs
        index=${the_new_dir:1}
        [[ -z $index ]] && index=1
        adir=$(dirs +$index)
        [[ -z $adir ]] && return 1
        the_new_dir=$adir
    fi

    # '~' has to be substituted by ${HOME}
    [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

    # Now change to the new dir and add to the top of the stack
    pushd "${the_new_dir}" > /dev/null
    [[ $? -ne 0 ]] && return 1
    the_new_dir=$(pwd)

    # Trim down everything beyond 11th entry
    popd -n +11 2>/dev/null 1>/dev/null

    # Remove any other occurence of this dir, skipping the top of the stack
    for ((cnt=1; cnt <= 10; cnt++)); do
        x2=$(dirs +${cnt} 2>/dev/null)
        [[ $? -ne 0 ]] && return 0
        [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
        if [[ "${x2}" == "${the_new_dir}" ]]; then
        popd -n +$cnt 2>/dev/null 1>/dev/null
        cnt=cnt-1
        fi
    done

    return 0
}
