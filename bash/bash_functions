# Functions

bak()
{
    cp $1 "$1.bak"
}

ansistrip()
{
    sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" -i $1
}

mkcd()
{
    mkdir $1 && cd $1
}

scratch()
{
  D="${HOME}/scratch/$(date +%s)/"

  mkdir -p $D && cd $D
}

command_exists()
{
    command -v "$1" >/dev/null 2>&1
}

s()
{
  echo mplayer -really-quiet "http://translate.google.com/translate_tts?tl=en\&q=$*" | \
  sed 's/ /+/3g' | sh 2>/dev/null;
}

psdt()
{
    if [ -z "$1" ]; then
        echo "Missing parameter. Usage: psdt {pid | name}"
        return 0
    fi
    
    x=$1
    ps aux | awk -v search="$x" 'NR == 1; $0 ~ search' | grep -v awk

}

soap()
{
    if [ $# -lt 2 ]; then
        echo "Missing parameter. Usage: soap {soap.xml} {url}"
        return 0
    fi
    
    curl -sk -H 'Content-Type: application/soap+xml;charset=UTF-8;action=urn:getStatus' -d @$1 -X POST $2 | \
        sed -e 's/\s\{2,\}/ /g' | \
        xmllint --format - | \
        pygmentize -f terminal256 -l xml -O style=monokai

}

allgit()
{
	if [ -z "$1" ]
	then
		echo Checking all git repositories in Home Directory...
		DIR=$HOME
	elif [ "$1" == "." ]
	then
		echo Checking all git repositories in $PWD...
		DIR=$1
	else
		echo Checking all git repositories in $1...
		DIR=$1
	fi

	for REPO in $(find $DIR -name ".git" -type d 2>/dev/null); do
	   WD=$(echo $REPO | awk -F/.git '{print $1}')
	   echo "-------------------------------------------------------------"
	   echo $WD | awk -v home="$HOME" '{ sub(home, "~"); print "Repository at: ", $0;}'
	   git --git-dir=$REPO --work-tree=$WD status 2>/dev/null | \
		 awk 'NR==1 {
				branch = $4
			}
			NR==2 {
				if($6=="clean)")printf("\t\033[0;32mBranch: \"%s\" is clean :)\033[0m\n",branch); 
				else printf("\t\033[0;31mBranch: \"%s\" is Dirty :(\033[0m\n",branch);
			}'
	done
}

gitstrip()
{
    if [ -z "$1" ]
    then
        echo Requires file-name to strip
        return 1
    fi

	BRANCH=$(git status 2>/dev/null | \
		 awk 'NR==1 { print $4 }')

    echo "Stripping file: $1" 
    echo "From repo branch $BRANCH"
    echo "Are you sure you'd like to continue? Y/N"
  
    read -s -n1 CONFIRM
    if [[ "$CONFIRM" != "y" && "$CONFIRM" != "Y" ]]; then
        echo "Exiting."
        return 0
    fi

    echo "*********************************************"
    
    git filter-branch --force --index-filter \
    "git rm --cached --ignore-unmatch $1" \
    --prune-empty --tag-name-filter cat -- --all

    echo "$1" >> .gitignore

    git add .gitignore    
    git commit -m "Added $1 to .gitignore"

    echo "*********************************************"
    echo "Push commit to remote using 'git push origin $BRANCH --force'"

}

passgen()
{
    if [ -z "$1" ]
    then
        echo Generating password with default length 16
		LEN=16
    else
        echo Generating password with length $1
		LEN=$1
	fi
    < /dev/urandom tr -dc [:graph:] | \
		head -c$LEN | \
		sed -e "s/.\(.\).\(.\).\(.*\)/$(< /dev/urandom tr -dc "0-9" | \
		head -c1)\1$(< /dev/urandom tr -dc "a-z" | \
		head -c1)\2$(< /dev/urandom tr -dc "A-Z" | \
		head -c1)\3/"
    echo 
}

parse_git_branch()
{
  git status 2>/dev/null | \
    awk 'NR==1 {
        branch = $4
    } 
    NR==2 {
        if( $6=="clean" )
            printf( "\033[00;32m  %s\033[0m\n", branch );
        else
            printf( "\033[00;31m  %s* \033[0m\n", branch );
    }'
}

# Display all the colors / ANSI codes available to the term
showcolors ()
{
    for x in 0 1 4 5 7 8; do 
        for i in `seq 30 37`; do 
            for a in `seq 40 47`; do 
                echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "
            done
            echo
        done
    done
    echo ""
}

# Show days passed since given date
# Borrowed from kjsharke
ageDay()
{ 
    echo $(( (`date +%s` - `date -d "$1" +%s`)/(3600*24) ));
}

sshp()
{
  list="${HOME}/.syncfiles"; [[ ! -f $list ]] && { ph "$list missing. Won't sync files."; nosync="true"; }
  [[ $# -eq 0 ]] && { exit 1; }
  host="$1"; shift; args="$@"
  p=$(pwd)
  if [ -z "$nosync" ]; then
    cd "$HOME"
    ct=`wc -l $list | awk '{ print $1 }'`
    n=1
    tar -cf - $(cat $list) | ssh "$host" 'tar -xf -' > /dev/null
  fi
  ssh "$host" "$args"
  cd "$p"
}


# This function defines a 'cd' replacement function capable of keeping, 
# displaying and accessing history of visited directories, up to 10 entries.
# To use it, uncomment it, source this file and try 'cd --'.
# acd_func 1.0.5, 10-nov-2004
# Petar Marinov, http:/geocities.com/h2428, this is public domain
cd_func ()
{
    local x2 the_new_dir adir index
    local -i cnt

    if [[ $1 ==  "--" ]]; then
        dirs -v
        return 0
    fi

    the_new_dir=$1
    [[ -z $1 ]] && the_new_dir=$HOME

    if [[ ${the_new_dir:0:1} == '-' ]]; then
        # Extract dir N from dirs
        index=${the_new_dir:1}
        [[ -z $index ]] && index=1
        adir=$(dirs +$index)
        [[ -z $adir ]] && return 1
        the_new_dir=$adir
    fi

    # '~' has to be substituted by ${HOME}
    [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

    # Now change to the new dir and add to the top of the stack
    pushd "${the_new_dir}" > /dev/null
    [[ $? -ne 0 ]] && return 1
    the_new_dir=$(pwd)

    # Trim down everything beyond 11th entry
    popd -n +11 2>/dev/null 1>/dev/null

    # Remove any other occurence of this dir, skipping the top of the stack
    for ((cnt=1; cnt <= 10; cnt++)); do
        x2=$(dirs +${cnt} 2>/dev/null)
        [[ $? -ne 0 ]] && return 0
        [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
        if [[ "${x2}" == "${the_new_dir}" ]]; then
        popd -n +$cnt 2>/dev/null 1>/dev/null
        cnt=cnt-1
        fi
    done

    return 0
}

# Function to traverse "up" filesystem from CWD
# Credit to reddit user /u/spdqbr
# http://www.reddit.com/r/commandline/comments/2o7rvh/linux_whats_a_good_alternative_to_stuff_like_cd/cmksmek
function cdup {
    newdir="${PWD/\/$1\/*/}/$1"
    if [[ -d "$newdir" ]]
    then
        cd "$newdir"
    else
        echo "\"$newdir\" does not exist"
    fi
}

function _cdup_complete {
    local word=${COMP_WORDS[COMP_CWORD]}
    local list=$(pwd | cut -c 2- | sed -e 's#/[^/]*$##g' -e 's/\([ ()]\)/\\\\\1/g')
    IFS=/
    list=$(compgen -W "$list" -- "$word")
    IFS=$'\n'
    COMPREPLY=($list)
    return 0
}

complete -F _cdup_complete cdup

