# If not running interactively, don't do anything
[[ "$-" != *i* ]] && return

# Source bash aliases
if [ -f "${HOME}/dotfiles/bash/bash_aliases" ]; then
  source "${HOME}/dotfiles/bash/bash_aliases"
fi

# Source bash functions
if [ -f "${HOME}/dotfiles/bash/bash_functions" ]; then
    source "${HOME}/dotfiles/bash/bash_functions"
fi

# Source private
if [ -f "${HOME}/dotfiles/bash/bash_private" ]; then
    source "${HOME}/dotfiles/bash/bash_private"
fi

# Add dir_colors (Linux only)
if [[ -z "$OSX" ]]; then
  eval $(dircolors $HOME/dotfiles/bash/dir_colors)
fi

# Add bash-completion (OS-X only, see brew bash-completion)
if [[ "$OSX" == "1" ]]; then
  if [ -f /usr/local/share/bash-completion/bash_completion ]; then
    . /usr/local/share/bash-completion/bash_completion
  fi
fi

# Go dev environment
export GOPATH="${HOME}/.go"
export GOROOT="$(brew --prefix golang)/libexec"
export PATH="$PATH:${GOPATH}/bin:${GOROOT}/bin"

# Source git completion functions
if [ -f "${HOME}/dotfiles/bash/git-completion" ]; then
    source "${HOME}/dotfiles/bash/git-completion"
fi

# Source git prompt functions
if [ -f "${HOME}/dotfiles/bash/git-prompt" ]; then
    source "${HOME}/dotfiles/bash/git-prompt"
    # Set options for the git PS1
    export GIT_PS1_SHOWDIRTYSTATE=1
    export GIT_PS1_SHOWSTASHSTATE=1
    export GIT_PS1_SHOWUNTRACKEDFILES=1
    export GIT_PS1_SHOWCOLORHINTS=1
    export GIT_PS1_SHOWUPSTREAM=1
fi

# Configure PAGER to use vim for man pages
# N.B. Make sure to clear $PAGER in vimrc so vim's Man function still works
export PAGER="/bin/sh -c \"unset PAGER;col -b -x | \
    vim -R -c 'set ft=man nomod nolist' -c 'map q :q<CR>' \
    -c 'map <SPACE> <C-D>' -c 'map b <C-U>' \
    -c 'nmap K :Man <C-R>=expand(\\\"<cword>\\\")<CR><CR>' -\""

# Bash history settings
shopt -s histappend
shopt -s cmdhist
export HISTFILE=$HOME/.history/bash_history
export HISTSIZE=
export HISTFILESIZE=
export HISTCONTROL="erasedups:ignoreboth"
export HISTTIMEFORMAT='%F %T '
export HISTIGNORE='ls:ll:exit:su:clear:bg:fg:history'

function  __prompt_command
{
  # This line MUST come first!
  local last_exit="$?"

  # Execute history commands: append, clear, rewrite
  history -a
  history -c
  history -r

  # ANSI Escape codes:
  local ANSI_reset="\[\033[00m\]"
  local ANSI_white="\[\033[00;37m\]"
  local ANSI_light_blue="\[\033[00;34m\]"
  local ANSI_green="\[\033[00;32m\]"
  local ANSI_red="\[\033[00;31m\]"
  local ANSI_purple="\[\033[00;35m\]"
  local ANSI_white_on_red="\[\033[00;37;41m\]"

  # Determine if we're connected via SSH to set host color in prompt
  if [[ -z ${SSH_CONNECTION+x} ]]; then
    local prompt_host="${ANSI_red}\h${ANSI_reset}"
  else
    local prompt_host="${ANSI_white_on_red}\h${ANSI_reset}"
  fi

  # Show the exit code of last command
  if [[ $last_exit -ne 0 ]]; then
    local prompt_status=" ${ANSI_white}[${ANSI_red}${last_exit}${ANSI_white}]${ANSI_reset} "
  else
    local prompt_status=" ${ANSI_white}[${ANSI_green}âœ”${ANSI_white}]${ANSI_reset} "
  fi

  # Determine if a python virtual env is set
  if [[ -z ${VIRTUAL_ENV+x} ]]; then
    local prompt_venv=''
  else
    local prompt_venv=" ${ANSI_purple}[py:${VIRTUAL_ENV##*/}]${ANSI_reset}"
  fi

  # Show current AWS environment (if set)
  if [[ -z ${AWS_PROFILE} ]]; then
    local prompt_aws=" ${ANSI_purple}[aws:default]${ANSI_reset}"
  else
    local prompt_aws=" ${ANSI_purple}[aws:${AWS_PROFILE}]${ANSI_reset}"
  fi

  # Build the prompt string:
  PS_PRE_GIT="${ANSI_light_blue}{ \w }${ANSI_reset}"
  PS_POST_GIT="${prompt_venv}${prompt_aws}\n${ANSI_green}\u${ANSI_light_blue}@${prompt_host}${prompt_status}${ANSI_white}$ ${ANSI_reset}"
}

PROMPT_COMMAND='__prompt_command; declare -F __git_ps1 &>/dev/null && __git_ps1 "$PS_PRE_GIT" "$PS_POST_GIT"'
